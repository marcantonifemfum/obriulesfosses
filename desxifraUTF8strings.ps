%!
%% https://www.rfc-editor.org/rfc/rfc3629
%% https://emnudge.dev/blog/utf-8/
%% https://util.unicode.org/UnicodeJsps/character.jsp
%% desxifrem les cadenes de text que, un cop aterrades dins l'int√®rpret GS, queden convertides en octets combiables (UTF-8) de fins a 4 (32 bits) per a 1 sol glif
%% per tal de tornar-les a xifrar codificades a 1 sol glif, sigui via nom (dins una array) o codi decimal (dins una string)
%% pels m√®todes de composici√≥ PostScript via Encoding/ToUnicode/show o via glyphshow necessitem o un nom o un codi (codepoint)
%% cal tenir present que el GS quan codifica un car√†cter de m√©s de 7 bits significatius, dins una string en UTF-8, sempre ho fa en notaci√≥ de base 8 \### octal
%% una A es codifica amb 1 sol octet (A)
%% un punt volat ¬∑ es codifica amb 2 octets (\302\267)
%% una el¬∑lipsi ‚Ä¶ es codifica amb 3 octets (\342\200\246)
%% hi ha emojis üòÄ i kanjis ©∏Ω que es codifiquen amb 4 octets (\360\237\230\200) (\360\251\270\275)

%% ens permet treballar amb plans de codificat diversos per poder representar p.e. kanjis, emojis o glifs japonesos (hiragana/katakana)
%% per√≤ inicialment treballarem amb el pla codificat dins l'Adobe Glyph List
systemdict /AdobeGlyphList get /araPla exch def  %% aquest √©s el pla que codificaci√≥ que farem servir (si trobem res m√©s enll√† avisarem i ho xifrarem amb un zero)
/maxAGL 65510 def  %% aquest √©s el codi decimal m√†xim codificat dins l'Adobe Glyph List (podr√≠em posar un comprovador si calgu√©s)
%% tamb√© es pot donar el cas que, sense superar maxAGL, la correspond√®ncia /nom vs codi decimal no hi sigui, com per exemple amb el cas del glif:
%% https://util.unicode.org/UnicodeJsps/character.jsp?a=30A0
%% <30A0> KATAKANA-HIRAGANA DOUBLE HYPHEN que equival a 16#30A0 = 12448 decimal i no es troba dins l'Adobe Glyph List
%% systemdict /AdobeGlyphList get {12448 eq{== stop}{pop}ifelse}forall
%% el glif („Ç†) un cop a l'stack es desglossa en (\343\202\240)

%% treballar dins un mateix text plans de codificaci√≥ diversos, en diferents sistemes d'escriptura, comporta treballar simult√†niament amb diferents tipografies
%% que s'haurien de cridar segons el rang de codificaci√≥ del glif (que s'hauria de saber abans de cridar la font de treball)

/d2a10 (2#00000000) def  %% primer tram de la m√†scara bin√†ria a codi decimal (radix number?)

/desem true def  %% gatell per saber si ja tenim el c√†lcul decimal fet per codificar 1 sol glif
/nomocodi false def  %% desem el nom o el codi?

/araGlifs [] def  %% on desem la l√≠nia de noms de glifs que desxifrem/xifrem
/araLinia () def  %% on desem la l√≠nia de codis que desxifrem/xifrem

%% casos diferents de com es comporta el xifrat d'1 sol glif:

%(\342\200\246)  %% 3 octets representen l'el¬∑lipsi que el seu nom PS dins l'Encoding √©s /ellipsis
%% s'ha d'embotir o encaixar en un sol codepoint en decimal que √©s 133 i per demostrar-ho:
%% systemdict /EncodingDirectory get /WinAnsiEncoding get 133 get == ens treu /ellipsis
%% systemdict /EncodingDirectory get /WinAnsiEncoding get /i 0 def {/ellipsis eq {i ==}if i 1 add /i exch def}forall ens treu 133

%(\243)  %% 163 A3 s√≠mbol de la lliura esterlina /sterling

(A)  %% 65 41 \101 lletra A maj√∫scula

%% excepcions que mai no s√≥n octet de cap√ßalera
%<C0>  %% 192 /Agrave
%<C1>  %% 193 /Aacute
%<F5>  %% 245 /otilde
%<FF>  %% 255 /ydieresis
%dup 0 get dup == /esn exch def

%% quin √©s el seu nom a l'AGL? ‚Ä¶i si no el trobem?
%araPla {xifrat eq{== exit}{pop}ifelse}forall

{  %% forall per tota la cadena de text
 dup /1octet exch def
 /8bits 8 string def  %% buffer de conversi√≥ d'1 octet a binari
 /8z (00000000) def  %% m√†scara de zeros a partir del segon octet

 desem
 {  %% hem de desar el glif? (el nom o el codi)
  /nOctts 0 def  %% nombre d'octets a interpretar
  dup 2 8bits cvrs dup /bin exch def length 8 eq
  {  %% podria tractar-se d'un octet de cap√ßalera?
   %% interroguem les excepcions que mai no s√≥n octet de cap√ßalera
   dup 192 eq  %% C0 \300 192 /Agrave
   {
(esel192c0)== quit
   }
   {
    dup 193 eq  %% C1 \301 193 /Aacute
    {
(esel193c1)== quit
    }
    {
     dup 245 eq  %% F5 \365 245 /otilde
     {
(esel245f5)== quit
     }
     {
      dup 255 eq  %% FF \377 255 /ydieresis
      {
(esel255ff)== quit
      }
      {  %% no el desarem perqu√® √©s un octet de cap√ßalera
       /iOctts 0 def  %% comptador d'octets per codificar el glif
       bin
       {  %% forall per saber quants 1 hi ha seguits que ens indicaran en quants octets s'ha descompost el glif
        49 eq
	{  %% √©s un 1
         iOctts 1 add /iOctts exch def
	}
        {  %% √©s un zero, desem i marxem
         iOctts /nOctts exch def  %% nombre d'octets a interpretar
	 exit
        }ifelse
       }forall
       iOctts 1 eq
       {  %% si nom√©s n'hi ha 1 ja l'hem d'escriure!
        nomocodi
	{  %% via nom
		(desemvianomdelglif)pstack quit
	}
	{  %% via codi
         araLinia dup length dup /araVa exch def 1 add string dup 3 -1 roll 0 exch putinterval
         dup 3 -1 roll araVa exch put /araLinia exch def
	}ifelse
(nomeshiha1u)pstack quit
       }
       {  %% si n'hi a 2 o m√©s hem d'iniciar l'embutit del xifrat
        pop  %% ens carreguem el decimal
        /desem false def  %% gatell per saber si ja tenim el c√†lcul decimal fet per codificar 1 sol glif
        bin nOctts 1 add dup 8 exch sub getinterval
(octetdecapsalera)pstack quit
       }ifelse
      }ifelse
     }ifelse
    }ifelse
   }ifelse
  }
  {  %% t√© 7 o menys bits significatius i l'escrivim directament
   nomocodi
   {  %% via nom
    (desemvianomdelglif)pstack quit
   }
   {  %% via codi
    araLinia dup length dup /araVa exch def 1 add string dup 3 -1 roll 0 exch putinterval
    dup 3 -1 roll araVa exch put /araLinia exch def
%%FET
   }ifelse
%%(te7omenysbitssignificatius)pstack quit
  }ifelse
 }
 {  %% no el desem perqu√® estem embutint el xifrat del glif?
(encaixantelglif)pstack quit
 }ifelse
}forall  %% per tota la cadena de text

%% deixem a l'stack el resultat, en noms de glifs o en codificaci√≥ directe, segons el pla (o plans) de codificaci√≥
nomocodi
{
 araGlifs
}
{
 araLinia
}ifelse

pstack

