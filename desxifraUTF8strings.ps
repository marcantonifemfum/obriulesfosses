%!
%% https://www.rfc-editor.org/rfc/rfc3629
%% https://emnudge.dev/blog/utf-8/
%% https://util.unicode.org/UnicodeJsps/character.jsp
%% aquest algorisme ens ha de permetre treballar amb tot l'univers Unicode, aix√≤ √©s:
%% amb tota mena de sistemes d'escriptura i alfabets, per representar glifs d'una cadena de text llat√≠, cir√≠l¬∑lic, kanji, emoji, hangul, hiragana/katakana, arabic, etc
%% https://ca.wikipedia.org/wiki/Escriptura#/media/Fitxer:WritingSystemsoftheWorld.png

%% desxifrem les cadenes de text que, un cop a l'stack de l'int√®rpret GS, queden convertides en octets combiables (UTF-8) de fins a 4 (32 bits) per a 1 sol glif
%% per tal de tornar-les a xifrar codificades a 1 sol codi decimal (que passat a hexa √©s consultable a Unicode) i nom PS (el de dins l'objecte /Encoding o ToUnicode)
%% doncs segons els m√®todes de composici√≥ PostScript via show o via glyphshow necessitarem o un codi (codepoint) o un nom
%% cal tenir present que el GS quan codifica un car√†cter de m√©s de 7 bits significatius, dins una string en UTF-8, sempre ho fa en notaci√≥ de base 8 \### octal
%% una A es codifica amb 1 sol octet (A)
%% un punt volat ¬∑ es codifica amb 2 octets (\302\267)
%% una el¬∑lipsi ‚Ä¶ es codifica amb 3 octets (\342\200\246)
%% hi ha emojis üòÄ i kanjis ©∏Ω que es codifiquen amb 4 octets (\360\237\230\200) (\360\251\270\275)

%% inicialment treballarem amb el pla codificat dins l'Adobe Glyph List
%systemdict /AdobeGlyphList get /araPla exch def  %% no cal doncs treballarem amb el ReverseAdobeGlyphList diccionari en format #numeric [/nomspossibles] de crida directa
/maxAGL 65510 def  %% aquest √©s el codi decimal m√©s gran codificat dins l'Adobe Glyph List (el m√©s petit √©s 1)

%% la casu√≠stica i el modus operandi que contemplarem ser√†:
%% si el xifrat √©s m√©s enll√† de maxAGL no l'escriurem, avisarem, i li assignarem un /.notdef
%% si el xifrat no es troba dins AGL no l'escriurem, avisarem, i li assignarem un /.notdef
%% si el xifrat es troba dins AGL per√≤ el codi √©s dins el rang de la PUA d'Unicode, avisarem, i escriurem el nom del glif
%% si el xifrat es troba dins AGL i √©s entre 0 i 255 (avisarem en mode debbug?) escriurem el codi
%% si el xifrat es troba dins AGL i √©s m√©s enll√† de 255 (avisarem en mode debbug?) escriurem el nom del glif

%%CASU√çSTICA A TENIR MOLT EN COMPTE
%% l'Adobe Glyph List s'adiu a Unicode, per√≤ un mateix codepoint pot tenir diversos noms PS de glif (p.e. 1488 [/alefhebrew /afii57664 /alef])
%% els codepoints decimals de l'AGL si els passem a hexa (p.e. 05D0 ‚Ä¶pel glif alef‚Ä¶ ◊ê) els podem consultar a‚Ä¶ https://util.unicode.org/UnicodeJsps/character.jsp?a=05d0
%% la WinAnsiEncoding NO s'adiu a Unicode en la codificaci√≥ de certs glifs (p.e. l'el¬∑lipsi codificada en decimal a 133)
%% tampoc en el nom PS d'alguns d'importants com‚Ä¶ /.notdef ‚Ä¶que no √©s dins l'AGL

%% als Encondings predeterminats que hi ha dins l' /EncodingDirectory del GS hi ha tota una col¬∑lecci√≥ de noms de glif que no existeixen dins l'AGL
%% si serv√≠s d'alguna cosa, podr√≠em desar-los via detectaglifsforadelAGL.ps
%% per la banda dels codis, cal veure quins codis de dins els Encodings predeterminats no s'adiuen o no es troben dins l'AGL
%% aquest comportament ens pot ser m√©s √∫til i ho podem desar via ????.ps
%% l'altra curiositat √©s saber quins glifs de l'AGL no s√≥n normatius d'Unicode doncs tenen el seu codepoint dins la PUA que va de‚Ä¶ <E000> 57344 ‚Ä¶fins‚Ä¶ <F8FF> 63743
%% ho podem veure a glifsPUAdinsAGL.ps

%% d'exemple de codi decimal que no hi √©s (sense superar maxAGL) tenim el cas del glif:
%% https://util.unicode.org/UnicodeJsps/character.jsp?a=30A0
%% <30A0> KATAKANA-HIRAGANA DOUBLE HYPHEN que equival a 16#30A0 = 12448 decimal i no es troba dins l'Adobe Glyph List
%% systemdict /AdobeGlyphList get {12448 eq{== stop}{pop}ifelse}forall
%% aquest glif („Ç†) un cop a l'stack es desglossa en (\343\202\240)

%% treballar dins un mateix text plans de codificaci√≥ diversos, en diferents sistemes d'escriptura, comporta treballar simult√†niament amb diferents tipografies
%% que s'haurien de cridar segons el rang de codificaci√≥ del glif (que s'hauria de saber abans de cridar la font de treball)

/d2a10 (2#00000000) def  %% primer tram de la m√†scara bin√†ria a codi decimal (radix number?)

/desem true def  %% gatell per saber si ja tenim el c√†lcul decimal fet per codificar 1 sol glif

%% decidim abandonar l'estrat√®gia de separar per codi o per nom el desat del glif
/nomocodi true def  %% desem el nom o el codi?
/araLinia () def  %% on desem la l√≠nia de codis que desxifrem/xifrem
%% ho desarem tot dins una array amb codi, amb nom o amb totes dues coses mesclades segons ens convingui
%% si desem dins una array el xifrat de cada glif podem mantenir la doble descripci√≥ [ #codi /nom ]
/araGlifs [] def  %% on desem la l√≠nia de noms de glifs que desxifrem/xifrem

%% casos diferents de com es comporta el xifrat d'1 sol glif:

%% testimoni de la Courier d'IBM que en certifica l'origen
%<F6BF>  %% codepoint 63167 a la PUA d'Unicode, ela geminada en caixa alta de nom /LL dins l'AGL
%<F6C0>  %% codepoint 63168 a la PUA d'Unicode, ela geminada en caixa baixa de nom /ll dins l'AGL

%%EP! aquest √©s un cas que demostra que primer hem de consultar la WinAnsiEncoding i despr√©s l'AGL, doncs l'el¬∑lipsi existeix a la primer per√≤ NO a la segona
%(\342\200\246)  %% un cop a l'stack (‚Ä¶) el protocol UTF-8 la transforma en 3 octets que representen l'el¬∑lipsi on el seu nom PS dins l'Encoding √©s /ellipsis
%% s'ha d'embotir o encaixar en un sol codepoint en decimal que √©s 133 i per demostrar-ho:
%% systemdict /EncodingDirectory get /WinAnsiEncoding get 133 get == ens treu /ellipsis
%% systemdict /EncodingDirectory get /WinAnsiEncoding get /i 0 def {/ellipsis eq {i ==}if i 1 add /i exch def}forall ens treu 133
%(‚Ä¶)

%(\243)  %% 163 A3 s√≠mbol de la lliura esterlina /sterling

%%FET
%(A)  %% 65 41 \101 lletra A maj√∫scula

%%FET
%% excepcions que mai no s√≥n octet de cap√ßalera
<C0>  %% 192 \300 /Agrave
%<C1>  %% 193 \301 /Aacute
%<F5>  %% 245 \365 /otilde
%<FF>  %% 255 \377 /ydieresis

%(„Ç†)  %% √©s un cas on per sota de maxAGL (codepoint 12448) no es troba dins l'AGL | Hiragana-Katakana Double Hyphen que a l'stack es desglossa en (\343\202\240)

%% (\240) cas d'un car√†cter amb 1 sol u de cap√ßalera al bit 8
%<A0>

%% quin √©s el seu nom a l'AGL? ‚Ä¶i si no el trobem?
%araPla {xifrat eq{== exit}{pop}ifelse}forall

{  %% forall per tota la cadena de text
 dup /1octet exch def
 /8bits 8 string def  %% buffer de conversi√≥ d'1 octet a binari
 /8z (00000000) def  %% m√†scara de zeros a partir del segon octet

 desem
 {  %% hem de desar el glif? (el nom o el codi)
  /nOctts 0 def  %% nombre d'octets a interpretar
  dup 2 8bits cvrs dup /bin exch def length 8 eq
  {  %% podria tractar-se d'un octet de cap√ßalera?
   %% interroguem les excepcions que mai no s√≥n octet de cap√ßalera
   dup 192 eq  %% C0 \300 192 /Agrave
   {
    nomocodi
    {  %% via nom
		(desemvianomdelglif Agrave)pstack quit
    }
    {  %% via codi
     araLinia dup length dup /araVa exch def 1 add string dup 3 -1 roll 0 exch putinterval
     dup 3 -1 roll araVa exch put /araLinia exch def
%%FET
    }ifelse
   }
   {
    dup 193 eq  %% C1 \301 193 /Aacute
    {
     nomocodi
     {  %% via nom
		(desemvianomdelglif Aacute)pstack quit
     }
     {  %% via codi
      araLinia dup length dup /araVa exch def 1 add string dup 3 -1 roll 0 exch putinterval
      dup 3 -1 roll araVa exch put /araLinia exch def
%%FET
     }ifelse
    }
    {
     dup 245 eq  %% F5 \365 245 /otilde
     {
      nomocodi
      {  %% via nom
		(desemvianomdelglif otilde)pstack quit
      }
      {  %% via codi
       araLinia dup length dup /araVa exch def 1 add string dup 3 -1 roll 0 exch putinterval
       dup 3 -1 roll araVa exch put /araLinia exch def
%%FET
      }ifelse
     }
     {
      dup 255 eq  %% FF \377 255 /ydieresis
      {
       nomocodi
       {  %% via nom
		(desemvianomdelglif ydieresis)pstack quit
       }
       {  %% via codi
        araLinia dup length dup /araVa exch def 1 add string dup 3 -1 roll 0 exch putinterval
        dup 3 -1 roll araVa exch put /araLinia exch def
%%FET
       }ifelse
      }
      {  %% no el desarem perqu√® √©s un octet de cap√ßalera
       /iOctts 0 def  %% comptador d'octets per codificar el glif
       bin
       {  %% forall per saber quants 1 hi ha seguits que ens indicaran en quants octets s'ha descompost el glif
        49 eq
	{  %% √©s un 1
         iOctts 1 add /iOctts exch def
	}
        {  %% √©s un zero, desem i marxem
         iOctts /nOctts exch def  %% nombre d'octets a interpretar
	 exit
        }ifelse
       }forall
       iOctts 1 eq
       {  %% si nom√©s n'hi ha 1 ja l'hem d'escriure!
        nomocodi
	{  %% via nom
/xifrat exch def /Nxifrat /.notdef def  %(desemvianomdelglif 1usol)pstack quit
%% coses a saber de cada glif
%% quin √©s el seu nom a l'AGL? ‚Ä¶i si no el trobem?
%% tant si el trobem com si no potser que el seu codi decimal sigui dins el rang PUA <E000> <f8ff> perqu√® es tracta d'un car√†cter no regulat encara per√≤ inclos a la Font
%% i si no es troba dins l'Encoding de la font de treball per√≤ s√≠ dins el CharStrings? ‚Ä¶i si no √©s en cap del dos llocs de la font de treball?
araPla {xifrat eq{/Nxifrat exch def exit}{pop}ifelse}forall
Nxifrat /.notdef eq
{
 (\n\n !!! el codi decimal... )print flush xifrat 32 string cvs print flush ( ...no es troba dins el xifrat de l'AGL ...PLEGUEM!\n)print flush
 ( >>> podeu consultar a Unicode de quin glif i sistema d'escriptura o d'alfabet es tracta... https://util.unicode.org/UnicodeJsps/character.jsp?a=)print flush
 /sHexa 16 string def xifrat 16 sHexa cvrs print flush (\n\n)print flush quit
}if
         Nxifrat araGlifs dup length dup /araVa exch def 1 add array dup 3 -1 roll 0 exch putinterval
         dup 3 -1 roll araVa exch put /araGlifs exch def
	}
	{  %% via codi
         araLinia dup length dup /araVa exch def 1 add string dup 3 -1 roll 0 exch putinterval
         dup 3 -1 roll araVa exch put /araLinia exch def
	}ifelse
%(nomeshiha1u)pstack quit
       }
       {  %% si n'hi a 2 o m√©s hem d'iniciar l'embutit del xifrat
        pop  %% ens carreguem el decimal
        /desem false def  %% gatell per saber si ja tenim el c√†lcul decimal fet per codificar 1 sol glif
        bin nOctts 1 add dup 8 exch sub getinterval
(octetdecapsalera)pstack quit
       }ifelse
      }ifelse
     }ifelse
    }ifelse
   }ifelse
  }
  {  %% t√© 7 o menys bits significatius i l'escrivim directament
   nomocodi
   {  %% via nom
    (desemvianomdelglif 7omenysglifs)pstack quit
   }
   {  %% via codi
    araLinia dup length dup /araVa exch def 1 add string dup 3 -1 roll 0 exch putinterval
    dup 3 -1 roll araVa exch put /araLinia exch def
%%FET
   }ifelse
%%(te7omenysbitssignificatius)pstack quit
  }ifelse
 }
 {  %% no el desem perqu√® estem embutint el xifrat del glif?
(encaixantelglif)pstack quit
 }ifelse
}forall  %% per tota la cadena de text

%% deixem a l'stack el resultat, en noms de glifs o en codificaci√≥ directe, segons el pla (o plans) de codificaci√≥
nomocodi
{
 araGlifs
}
{
 araLinia
}ifelse

pstack

