%!
%% https://www.rfc-editor.org/rfc/rfc3629
%% https://emnudge.dev/blog/utf-8/
%% https://util.unicode.org/UnicodeJsps/character.jsp
%% aquest algorisme ens ha de permetre treballar amb tot l'univers Unicode, aix√≤ √©s:
%% amb tota mena de sistemes d'escriptura i alfabets, per representar glifs d'una cadena de text llat√≠, cir√≠l¬∑lic, kanji, emoji, hangul, hiragana/katakana, arabic, etc
%% https://ca.wikipedia.org/wiki/Escriptura#/media/Fitxer:WritingSystemsoftheWorld.png

%%FILOSOFIA BREU:
%% desxifrem cadenes de text, glif a glif, en base a 2 refer√®ncies: l' /encodingDtreball d'acord amb la tipografia amb la que estiguem component
%% i a Unicode, d'acord amb els diccionaris de AdobeGlyphList i ReverseAdobeGlyphList (AGL), per√≤ podr√≠em construir-ne d'altres
%% El sesultat pel desxifrat de cada glif √©s una array en format: 
%% [
%%  #codiE  codi decimal (enter) del glif dins l' /encodingDtreball, si no existeix hi deixaren un null
%%  [/nomPS ‚Ä¶ ] array amb 1 o m√©s noms PS del glif, on el primer de tots ser√† el que segur existeixi dins l' /encodingDtreball
%%  #codiU  codi decimal (enter) Unicode (codepoint) del glif dins l'AGL, si no existeix hi deixarem un null
%% ]
%% al final de l'algorisme hauriem de comprovar, glif a glif, que algun dels literals de l'array de noms PS existeix dins CharStrings del tipus a compondre

%% desxifrem les cadenes de text que, un cop a l'stack de l'int√®rpret GS, es destrien en octets combiables (UTF-8) de fins a 4 (32 bits) per a 1 sol glif
%% pensem que un cop 1 sol glif s'han desembolicat en UTF's. a l'stack, cap operador PS els reinterpreta, i.e. (üòÄ) t√© un length de 4 
%% per aix√≤ cal tornar-les a xifrar codificades a 1 sol codi decimal: com a √≠ndex a l' /encodingDtreball i/o codepoint hexa consultable en una taula Unicode (com AGL)
%% i tamb√© el nom PS possible, sigui: el de dins l' /encodingDtreball i/o l'objecte /ToUnicode de PDF i/o Unicode (l'AGL o d'altres que es puguin crear)
%% doncs segons els m√®todes de composici√≥ PostScript via show o via glyphshow necessitarem o un codi (codepoint) o un nom
%% cal tenir present que el GS quan codifica un car√†cter de m√©s de 7 bits significatius, dins una string en UTF-8, sempre ho fa amb notaci√≥ en base 8 \### octal
%% una A es codifica amb 1 sol octet (A)
%% un punt volat ¬∑ es codifica amb 2 octets (\302\267)
%% una el¬∑lipsi ‚Ä¶ es codifica amb 3 octets (\342\200\246)
%% hi ha emojis üòÄ i kanjis ©∏Ω que es codifiquen amb 4 octets (\360\237\230\200) (\360\251\270\275)

%% ara la refer√®ncia Unicode ser√† el diccionari AdobeGlyphList (/nomPS #codiUnicode) on noms diferents poden compartir codi!
%% i la seva versi√≥ invertida ReverseAdobeGlyphList un diccionari (#codiUnicode [/nomsPSpossibles]) que es agrupa noms PS diferents dins un mateix codi decimal
%% com que a ReverseAdobeGlyphList podem consultar per codi, deixa de tenir sentit interrgoar per /maxAGL
%/maxAGL 65510 def  %% aquest √©s el codi decimal m√©s gran codificat dins l'Adobe Glyph List (el m√©s petit √©s 1)
%% /MAX 0 def /MIN 100 def ReverseAdobeGlyphList {pop dup MAX gt{/MAX exch def}{dup MIN lt{/MIN exch def}{pop}ifelse}ifelse}forall

%%ON INFORMEM?
%% si no hi ha #codepoint a l'AGL ‚Ä¶veure #CAS02
%% si el #codepoint existeix dins l' /encodingDtreball per√≤ a punta a un /.notdef  ‚Ä¶veure #CAS02
%% si el #codepoint √©s dins una √†rea PUA?
%% si no hi ha nom PS a l' /encodingDtreball?
%% si no hi ha glif a ChasStrings?

%%CASU√çSTICA A TENIR MOLT EN COMPTE
%% l'Adobe Glyph List s'adiu a Unicode, per√≤ un mateix codepoint pot tenir diversos noms PS de glif (p.e. 1488 [/alefhebrew /afii57664 /alef])
%% els codepoints decimals de l'AGL si els passem a hexa (i.e. 05D0 ‚Ä¶pel glif alef‚Ä¶ ◊ê) els podem consultar a‚Ä¶ https://util.unicode.org/UnicodeJsps/character.jsp?a=05d0
%% la WinAnsiEncoding NO s'adiu a Unicode en la codificaci√≥ de certs glifs: i.e. l'el¬∑lipsi es codifica en decimal a 133 dins l'Encoding per√≤ a Unicode √©s a 8230
%% tampoc un nom PS important com‚Ä¶ /.notdef ‚Ä¶no √©s dins l'AGL i n'hi poden haver d'altres que estiguin dins l' /encodingDtreball i no a l'AGL
%% si explorem la codificaci√≥ de l'encoding m√©s habitual WinAnsiEncoding per veure quins glifs s√≥n /.notdef | veurem que s√≥n del 0 al 31
% systemdict /EncodingDirectory get /WinAnsiEncoding get 0 1 255{2 copy get /.notdef eq {==}{pop}ifelse}for

%% als Encondings predeterminats que hi ha dins l' /EncodingDirectory del GS hi ha tota una col¬∑lecci√≥ de noms de glif que no existeixen dins l'AGL
%% quan aix√≤ passi, per indicar-ho (a banda d'avisar pel prompt), posarem un null a la posici√≥ 1 de l'array de noms PS
%% si serv√≠s d'alguna cosa, podr√≠em desar-los via detectaglifsforadelAGL.ps
%% per la banda dels codis, cal veure quins codis de dins els Encodings predeterminats no s'adiuen o no es troben dins l'AGL
%% aquest comportament ens pot ser m√©s √∫til i ho podem consultar via fontEncodingGlifsNOunicode.ps
%% l'altra curiositat √©s saber quins glifs de l'AGL no s√≥n normatius d'Unicode doncs tenen el seu codepoint dins la PUA que va de‚Ä¶ <E000> 57344 ‚Ä¶fins‚Ä¶ <F8FF> 63743
%% ho podem veure a glifsPUAdinsAGL.ps

%% treballar la composici√≥ del text via codis decimals o via noms dels glifs, pot estar condicionada al xifrat de certs glifs m√©s enll√† de 255
%% fora de l'abast dels /Encoding tradicionals, de 256 elements, dels tipus de lletra que remena el GS
%%Experiment: qu√® passa si re-xifrem una tipografia amb un /Encoding d+d 256 elements?
%%ATENCI√ì: dins un context de producci√≥, caldria treballar amb l' /Encoding de la tipografia en actiu‚Ä¶ currentfont /Encoding get ‚Ä¶doncs pot estar re-codificada!
systemdict /EncodingDirectory get
/WinAnsiEncoding
%/StandardEncoding  %% il¬∑lustra molt b√© el CAS02
%/ISOLatin1Encoding
dup /NOMencoding exch def
get

%%CAS04-A-B simulem un Encoding m√©s curt de 256 i en fem un de nom√©s 128 elements
0 128 getinterval

/encodingDtreball exch def
%% si treballem via nom del glif nom√©s ens caldra assegurar (havent pentinat abans els CharStrings del tipus, veure FuraFont) que el glif existeix dins la font activa

%% d'exemple de codi decimal que no hi √©s (sense superar maxAGL) tenim el cas del glif:
%% https://util.unicode.org/UnicodeJsps/character.jsp?a=30A0
%% <30A0> KATAKANA-HIRAGANA DOUBLE HYPHEN que equival a 16#30A0 = 12448 decimal i no es troba dins l'Adobe Glyph List
%% systemdict /AdobeGlyphList get {12448 eq{== stop}{pop}ifelse}forall
%% aquest glif („Ç†) un cop a l'stack es desglossa en (\343\202\240)

%% treballar dins un mateix text plans de codificaci√≥ diversos, en diferents sistemes d'escriptura, comportaria treballar simult√†niament amb diferents tipografies
%% i diferents /encodingDtreball que s'haurien de cridar segons el glif a compondre (haur√≠em de veure com detectar la font de treball/Encoding)

%% encara no ho fem servir?
/d2a10 (2#00000000) def  %% primer tram de la m√†scara bin√†ria a codi decimal (radix number?)

/desem true def  %% gatell per saber si ja tenim el c√†lcul decimal fet (d'UTF-8 a 1 sol decimal) per codificar un sol glif

/araGlifs [] def  %% aqu√≠ √©s on desarem les arrays de cada glif amb triple descripci√≥



%%CASU√çSTICA de diferents comportament en el xifrat d'1 sol glif:

%%CAS04-A
%1 string dup 0 129 put  %% en aquest cas el glif /bullet (amb 8 bits significatius i un 1 al bit 8) ja queda m√©s enll√† de l' /encodingDtreball que hem escur√ßat
%%CAS04-B
1 string dup 0 161 put  %% en aquest cas el glif /exclamdown (amb 8 bits significatius i un 1 al bit 8) ja queda m√©s enll√† de l' /encodingDtreball que hem escur√ßat

%%CAS##
%% testimoni de la Courier d'IBM que en certifica l'origen
%<F6BF>  %% codepoint 63167 a la PUA d'Unicode, ela geminada en caixa alta de nom /LL dins l'AGL
%<F6C0>  %% codepoint 63168 a la PUA d'Unicode, ela geminada en caixa baixa de nom /ll dins l'AGL

%%CAS##
%%EP! aquest √©s un cas que demostra que primer hem de consultar la WinAnsiEncoding i despr√©s l'AGL, doncs l'el¬∑lipsi existeix a la primer per√≤ NO a la segona
%(\342\200\246)  %% un cop a l'stack (‚Ä¶) el protocol UTF-8 la transforma en 3 octets que representen l'el¬∑lipsi on el seu nom PS dins l'Encoding √©s /ellipsis
%% s'ha d'embotir en un decimal que √©s 133 al WinAnsiEncoding de la font tipogr√†fica i per demostrar-ho:
%% systemdict /EncodingDirectory get /WinAnsiEncoding get 133 get == ens treu /ellipsis
%% systemdict /EncodingDirectory get /WinAnsiEncoding get /i 0 def {/ellipsis eq {i ==}if i 1 add /i exch def}forall ens treu 133
%(‚Ä¶)  %% per√≤ a Unicode el seu codepoint normatiu √©s a 8230

%%CAS##
%(\243)  %% 163 A3 s√≠mbol de la lliura esterlina /sterling

%%CAS03
%( )  %% <20> hi mancaria el filtrat a l'AGL doncs hi √©s i ara apareix fora d'un array
%(A)  %% 65 41 \101 lletra A maj√∫scula | amb /StandardEncoding -es un CAS02
%(AEIOUaeiou)

%%CAS05-06-07-08
%<c0c1f5ff>
%% excepcions segons la normativa rfc3629, que mai no s√≥n octet de cap√ßalera
%%CAS05
%<C0>  %% 192 \300 /Agrave
%%CAS06
%<C1>  %% 193 \301 /Aacute
%%CAS07
%<F5>  %% 245 \365 /otilde
%%CAS08
%<FF>  %% 255 \377 /ydieresis

%%CAS##
%% aquest s'ha d'embotir perqu√® es destria en 3 UTF-8
%(„Ç†)  %% √©s un cas on per sota de maxAGL (codepoint 12448) no es troba dins l'AGL | Hiragana-Katakana Double Hyphen que a l'stack es desglossa en (\343\202\240)

%%CAS##
%% Unicode NON-BREAK SPACE (\240) cas d'un car√†cter amb 1 sol u de cap√ßalera al bit 8
%% que al WinAnsiEncoding t√© al decimal 160 el nom /space i que aqu√≠ correspon tamb√© a l'espai normal 32 decimal, per√≤ als noms de l'AGL no hi surt com a /space
%% en canvi el 32 decimal (<20> hexa) dins l'AGL t√© 2 noms dins l'array i /space no o cupa l'√≠ndex 0 dins aquest array de l'AGL
%% systemdict /EncodingDirectory get /WinAnsiEncoding get 0 1 255 { 2 copy get /space eq {==}{pop}ifelse }for
%<A0>

%%CAS##
%<00>  %% Error: /undefined in --get--

%%CAS##
%% 1 string dup 0 191 put  %% nom√©s hi ha un 1 al 8√® bit i existeix dins l'AGL

%%CAS01
%% si explorem la codificaci√≥ dels glifs que estan definits amb 1 sol octet per saber quins NO existeixen dins l'AGL i quins amb 8 bits sencers comencen per 10:
%% veurem que els que no existeixen dins l'AGL s√≥n el zero i del 128 al 159 i aquests darrers tenen 8 bits significatius i comencen tots per 10
% 0 1 255
% {  %% for
%  dup dup /8b 16 string def 2 8b cvrs dup length 8 eq
%  {  %% posant especial atenci√≥ als que tenen els 8 bits significatius
%   0 2 getinterval (10) eq
%   {  %% i d'aquestos els que comencen en 10
%    /a+ (*) def
%   }
%   {
%    /a+ () def
%   }ifelse
%  }
%  {
%   pop /a+ () def
%  }ifelse
%  ReverseAdobeGlyphList exch known
%  {
%   pop
%  }
%  {  %% anotem a pantalla quins NO existeixen
%   16 string cvs print flush a+ print flush (\n)print flush
%  }ifelse
% }for
%%CAS01 amb /encodingDtreball /WinAnsiEncoding
%(SI++-------------------)pstack quit
%1 string dup 0 159 put

%%CAS02 amb /encodingDtreball /StandardEncoding
%(NO++-------------------)pstack quit
%1 string dup 0 159 put

%%CAS00 amb /encodingDtreball /WinAnsiEncoding
%1 string dup 0 191 put
%<BF>


{  %% forall per tota la cadena de text
 dup /1octet exch def
 /8bits 8 string def  %% buffer de conversi√≥ d'1 octet a binari
 /8z (00000000) def  %% m√†scara de zeros a partir del segon octet

 desem
 {  %% hem de desar el glif directament o estem embutint un UTF?
  /nOctts 0 def  %% nombre d'octets a interpretar
  dup 2 8bits cvrs dup /bin exch def length 8 eq
  {  %% podria tractar-se d'una excepci√≥ o d'un octet de cap√ßalera?
   %% interroguem les excepcions que mai no s√≥n octet de cap√ßalera
   dup 192 eq  %% C0 \300 192 /Agrave
   {  %% una excepci√≥
%%CAS05
    dup 3 array dup 3 -1 roll 0 exch put dup dup  %% aqu√≠ hi desarem les 3 dades del glif, comen√ßant pel codi que ens ve de la cadena de text
    4 -1 roll encodingDtreball exch get 1 exch put  %% desem el nom que, per codi, li correspon a l'Encoding de treball (aqu√≠ no caldr√† comprovar-ho)
    dup 1 get AdobeGlyphList exch get 2 exch put  %% desem el seu codi Unicode que, per nom, li correspon dins l'AGL (aqu√≠ no caldr√† comprovar-ho)
    %% desem l'array de les 3 dades del glif dins l'array dels glifs a compondre
    araGlifs dup length dup /araVa exch def 1 add array dup 3 -1 roll 0 exch putinterval
    dup 3 -1 roll araVa exch put /araGlifs exch def
(perFER1)pstack quit
   }
   {
    dup 193 eq  %% C1 \301 193 /Aacute
    {  %% una excepci√≥
%%CAS06
     dup 3 array dup 3 -1 roll 0 exch put dup dup  %% aqu√≠ hi desarem les 3 dades del glif, comen√ßant pel codi que ens ve de la cadena de text
     4 -1 roll encodingDtreball exch get 1 exch put  %% desem el nom que, per codi, li correspon a l'Encoding de treball (aqu√≠ no caldr√† comprovar-ho)
     dup 1 get AdobeGlyphList exch get 2 exch put  %% desem el seu codi Unicode que, per nom, li correspon dins l'AGL (aqu√≠ no caldr√† comprovar-ho)
     %% desem l'array de les 3 dades del glif dins l'array dels glifs a compondre
     araGlifs dup length dup /araVa exch def 1 add array dup 3 -1 roll 0 exch putinterval
     dup 3 -1 roll araVa exch put /araGlifs exch def
(perFER2)pstack quit
    }
    {
     dup 245 eq  %% F5 \365 245 /otilde
     {  %% una excepci√≥
%%CAS07
      dup 3 array dup 3 -1 roll 0 exch put dup dup  %% aqu√≠ hi desarem les 3 dades del glif, comen√ßant pel codi que ens ve de la cadena de text
      4 -1 roll encodingDtreball exch get 1 exch put  %% desem el nom que, per codi, li correspon a l'Encoding de treball (aqu√≠ no caldr√† comprovar-ho)
      dup 1 get AdobeGlyphList exch get 2 exch put  %% desem el seu codi Unicode que, per nom, li correspon dins l'AGL (aqu√≠ no caldr√† comprovar-ho)
      %% desem l'array de les 3 dades del glif dins l'array dels glifs a compondre
      araGlifs dup length dup /araVa exch def 1 add array dup 3 -1 roll 0 exch putinterval
      dup 3 -1 roll araVa exch put /araGlifs exch def
(perFER3)pstack quit
     }
     {
      dup 255 eq  %% FF \377 255 /ydieresis
      {  %% una excepci√≥
%%CAS08
       dup 3 array dup 3 -1 roll 0 exch put dup dup  %% aqu√≠ hi desarem les 3 dades del glif, comen√ßant pel codi que ens ve de la cadena de text
       4 -1 roll encodingDtreball exch get 1 exch put  %% desem el nom que, per codi, li correspon a l'Encoding de treball (aqu√≠ no caldr√† comprovar-ho)
       dup 1 get AdobeGlyphList exch get 2 exch put  %% desem el seu codi Unicode que, per nom, li correspon dins l'AGL (aqu√≠ no caldr√† comprovar-ho)
       %% desem l'array de les 3 dades del glif dins l'array dels glifs a compondre
       araGlifs dup length dup /araVa exch def 1 add array dup 3 -1 roll 0 exch putinterval
       dup 3 -1 roll araVa exch put /araGlifs exch def
(perFER4)pstack quit
      }
      {  %% no el desarem perqu√® √©s un octet de cap√ßalera?
       /iOctts 0 def  %% comptador d'octets per codificar el glif
       bin
       {  %% forall per saber quants 1 hi ha seguits, fins al primer zero, que ens indicaran en quants octets UTF-8 s'ha descompost el glif
        49 eq
	{  %% √©s un 1
         iOctts 1 add /iOctts exch def
	}
        {  %% √©s un zero, desem i marxem
         iOctts /nOctts exch def  %% nombre d'octets a interpretar
	 exit
        }ifelse
       }forall

       iOctts 1 eq
       {  %% si nom√©s n'hi ha 1, √©s un UTF de nom√©s 8 bits/1 octet, i ja l'hem d'escriure!

%***% an√†lisi a replicar un cop tenim el codi definitu del glif:

	/xifrat exch def  %% enter decimal del glif desxifrat
	/Nxifrat /.notdef def  %% nom del glif si no el trobem
	/Aglif 3 array def  %% array amb les 3 descripcions possibles del glif: √≠ndex a l' /encodingDtreball /PSglif #codepoint d'Unicode
	/PSglif 1 array def  %% array amb els noms PS del glif

%00% el /xifrat √©s dins de l' /encodingDtreball ? >>> o %1% o %2% 
	xifrat encodingDtreball length 1 sub le
	{
%02% el /xifrat √âS DINS l' /encodingDtreball, posem el seu /nompsE a l'√≠ndex 0 de /PSglif i posem  el /xifrat a l'√≠ndex 0 i /PSglif a l'1 de l' /Aglif i passem a %3% %6%
         encodingDtreball xifrat get /nompsE exch def

	 nompsE /.notdef eq  %% √©s un glif NO definit?
	 {
%%CAS02
          (\n\n )print flush xifrat 128 string cvs print flush ( <<< el glif s'ha definit com a /.notdef dins l'Encoding de treball... )print flush
	  NOMencoding 128 string cvs print flush
         }if

	 PSglif dup 0 nompsE put /PSglif exch def
	 Aglif dup 0 xifrat put dup 1 PSglif put /Aglif exch def

%03% el /xifrat √©s dins l'AGL? >>> o %4% o %5%
        ReverseAdobeGlyphList xifrat known
        {  %% n'extraiem el /nompsAGL
%%CAS00
%05% el /xifrat √âS DINS l'AGL, busquem l'array del seu /nompsAGL i reorganitzem /PSglif com %09%, i posem el #codepoint a l'√≠ndex 2 de l'array del glif
         ReverseAdobeGlyphList xifrat get /nompsAGL exch def
         %% comparem el /nompsE amb el /nompsAGL reorganitzant l'array, si conv√©, per asseguranr-nos que el /nompsE √©s el primer element de l'array
         /nompsEhies false def  %% gatell per saber si √©s dins AGL o no
         
	 nompsAGL 0 1 2 index length 1 sub
         {  %% for per saber si el literal /nompsE existeix dins l'array /nompsAGL
          %% doncs si no existeix, avisarem i haurem d'ampliar l'array /nompsAGL per ficar-li, sempre a la posici√≥ 0
          %% si existeix i no √©s a la posici√≥ 0 reorganitzarem l'array perqu√® hi sigui
          2 copy get nompsE eq
          {  %% hi √©s
           /nompsEhies true def
           exit
          }
          {
           pop
          }ifelse
         }for

%09% organitzaci√≥ de /PSglif: a l'√≠ndex 0 sempre hi ha d'haver el nom PS de l' /encodingDtreball i a partir de l√≠ndex 1 la resta de noms de l'AGL (si hi s√≥n)
         nompsEhies
         {  %% si hi √©s ens assegurem que √©s a la posici√≥ zero i si no reorganitzem l'array
          dup 0 eq
          {  %% √©s a la posici√≥ 0, o sigui al capdavant de l'array
           pop
          }
          {  %% no √©s a la posici√≥ 0 reorganizem l'array (del qu√® ser√† /PSglif) perqu√® hi estigui
           mark 3 1 roll  %% posem una marca per poder jugar qmab qualsevol nombre de noms de glifs
           /ai0 exch def  %% posici√≥ a l'stack que anir√† a l'√≠ndex zero
           aload pop counttomark ai0 roll
           counttomark array astore
           exch pop  %% ens carreguem la mark
          }ifelse
         }
         {  %% si no hi √©s, ampliem l'array (del qu√® ser√† /PSglif) i el posem a la posici√≥ 0
          pop dup length 1 add array dup dup 4 -1 roll 1 exch putinterval 0 nompsE put
         }ifelse
         dup /PSglif exch def
         %% al darrer √≠ndex de /PSglif sempre hi haur√† el literal amb el que podrem consultar el #codepoint d'Unicode a l'AGL
	 dup length 1 sub get AdobeGlyphList exch get
         %% aqu√≠ acabem de muntar l'array /Aglif
         Aglif exch 2 exch put  %% el #codepoint d'Unicode
         Aglif dup 1 PSglif put  %% el(s) nom(s) PS del glif
         %% desem l'array /Aglif del glif dins l'array /araGlifs dels glifs a compondre
         araGlifs dup length dup /araVa exch def 1 add array dup 3 -1 roll 0 exch putinterval
         dup 3 -1 roll araVa exch put /araGlifs exch def
        }
        {
%04% el /xifrat NO √©s DINS l'AGL, tant si ve de %1% com de %2%, intentem cercar si el /nompsE hi √©s
         %% primer buscarem si el seu nompsE √©s dins l'AGL
         AdobeGlyphList nompsE known
         {  %% si a l'AGL HI √âS, posarem el seu codi Unicode de l'AGL a l'√≠ndex 2 d' /Aglif
%%CAS01
          AdobeGlyphList nompsE get Aglif exch 2 exch put
%(SI++-------------------)
         } 
         {  %% si a l'AGL NO HI √âS, mirarem les √†rees PUA i n'informarem pel prompt si √©s normatiu Unicode o no, deixant el #codepoint o un NULL a l'√≠ndex 2 d' /Aglif
%%CAS02
          (\n\n )print flush xifrat 128 string cvs print flush ( <<< el #codepoint d'Unicode no existeix dins l'Adobe Glyph List)print flush
%(NO++-------------------)
%10% si el /xifrat NO √©s DINS l'AGL, hem de mirar si el #codepoint √©s dins d'una √†rea PUA, si ho √©s, posarem un NULL a l'√≠ndex 2 d' /Aglif, i si no el seu #codepoint
         }ifelse
	 
         %% desem l'array /Aglif del glif dins l'array /araGlifs dels glifs a compondre
         Aglif araGlifs dup length dup /araVa exch def 1 add array dup 3 -1 roll 0 exch putinterval
         dup 3 -1 roll araVa exch put /araGlifs exch def
        }ifelse
       }
       {  %% nom√©s si es fes servir un /encodingDtreball curt, de menys de 256, i llegint glifs amb 8 bits significatius amb un 1 al bit 8, passariem per aqu√≠
%% doncs som dins el rang de /xifrat que es descriu amb 1 sol octet
%%CAS04-A-B exemple for√ßant un Encoding m√©s curt de 255, de nomes 129 elements

%01% el /xifrat NO √©s DINS l' /encodingDtreball, posem un /.notdef a l'√≠ndex 0 de l'array /PSglif i deixem el NULL a l'√≠ndex 0 de l'array /Aglif i passem a %3%
        PSglif dup 0 /.notdef put
	Aglif dup 3 -1 roll 1 exch put
	ReverseAdobeGlyphList xifrat known
	{  %% tot i ser dins l'AGL tamb√© podria
%(ENCODINGcurtDINSagl)pstack quit
%%CAS04-B
%10% si el /xifrat NO √©s DINS l'AGL, hem de mirar si el #codepoint √©s dins d'una √†rea PUA, si ho √©s, posarem un NULL a l'√≠ndex 2 d' /Aglif, i si no el seu #codepoint
%% si NO √©s normatiu d'Unicode n'informarem pel prompt de quina de les √†rees de les anomenades ¬´Unassigned, Private use, or Surrogates¬ª pertany:
         %% extret de‚Ä¶ blocsUnicode.ps
         %% un bloc que va del decimal‚Ä¶ 55296 ‚Ä¶al decimal‚Ä¶ 63743
            %% High_Surrogates [\uD800-\uDB7F] ‚Ä¶del decimal‚Ä¶ 55296 ‚Ä¶fins‚Ä¶ 56191
            %% High_Private_Use_Surrogates | High_PU_Surrogates [\uDB80-\uDBFF] ‚Ä¶del decimal‚Ä¶ 56192 ‚Ä¶fins‚Ä¶ 56319
            %% Low_Surrogates [\uDC00-\uDFFF] ‚Ä¶del decimal‚Ä¶ 56320 ‚Ä¶fins‚Ä¶ 57343
            %% PUA | Private_Use_Area | Private_Use [\uE000-\uF8FF] ‚Ä¶del decimal‚Ä¶ 57344 ‚Ä¶fins‚Ä¶ 63743
         %% un bloc que va del decimal‚Ä¶ 983040 ‚Ä¶al decimal‚Ä¶ 1114111
            %% Sup_PUA_A | Supplementary_Private_Use_Area_A [U+F0000-U+FFFFF] ‚Ä¶del decimal‚Ä¶ 983040 ‚Ä¶fins‚Ä¶ 1048575
            %% Sup_PUA_B | Supplementary_Private_Use_Area_B [U+100000-U+10FFFF] ‚Ä¶del decimal‚Ä¶ 1048576 ‚Ä¶fins‚Ä¶ 1114111

         xifrat 55296 ge xifrat 63743 le and xifrat 983040 ge xifrat 1114111 le and or
	 { %% filtra en quin dels 2 grans blocs ¬´Unassigned, Private use, or Surrogates¬ª podria pert√†nyer
          xifrat 55296 ge xifrat 63743 le and
	  {
           xifrat 56191 le
	   {  %% High_Surrogates [\uD800-\uDB7F] ‚Ä¶del decimal‚Ä¶ 55296 ‚Ä¶fins‚Ä¶ 56191
            (\n\n )print flush xifrat 128 string cvs print flush
            ( <<< Unicode privat del bloc: High_Surrogates [\\uD800-\\uDB7F] del decimal 55296 fins 56191)print flush
	   }
           {
            xifrat 56319 le
	    {  %% High_Private_Use_Surrogates | High_PU_Surrogates [\uDB80-\uDBFF] ‚Ä¶del decimal‚Ä¶ 56192 ‚Ä¶fins‚Ä¶ 56319
             (\n\n )print flush xifrat 128 string cvs print flush
             ( <<< Unicode privat del bloc: High_Private_Use_Surrogates | High_PU_Surrogates [\\uDB80-\\uDBFF] ‚Ä¶del decimal‚Ä¶ 56192 ‚Ä¶fins‚Ä¶ 56319)print flush
	    }
            {
             xifrat 57343 le
             {  %% Low_Surrogates [\uDC00-\uDFFF] ‚Ä¶del decimal‚Ä¶ 56320 ‚Ä¶fins‚Ä¶ 57343
              (\n\n )print flush xifrat 128 string cvs print flush
              ( <<< Unicode privat del bloc: Low_Surrogates [\\uDC00-\\uDFFF] ‚Ä¶del decimal‚Ä¶ 56320 ‚Ä¶fins‚Ä¶ 57343)print flush
	     }
             {
              xifrat 63743 le
	      {  %% PUA | Private_Use_Area | Private_Use [\uE000-\uF8FF] ‚Ä¶del decimal‚Ä¶ 57344 ‚Ä¶fins‚Ä¶ 63743
               (\n\n )print flush xifrat 128 string cvs print flush
               ( <<< Unicode privat del bloc: PUA | Private_Use_Area | Private_Use [\\uE000-\\uF8FF] ‚Ä¶del decimal‚Ä¶ 57344 ‚Ä¶fins‚Ä¶ 63743)print flush
	      }
              {  %% √©s entre 983040 i 1114111
               xifrat 1048575 le
               {  %% Sup_PUA_A | Supplementary_Private_Use_Area_A [U+F0000-U+FFFFF] ‚Ä¶del decimal‚Ä¶ 983040 ‚Ä¶fins‚Ä¶ 1048575
                (\n\n )print flush xifrat 128 string cvs print flush
                ( <<< Unicode privat del bloc: Sup_PUA_A | Supplementary_Private_Use_Area_A [U+F0000-U+FFFFF] ‚Ä¶del decimal‚Ä¶ 983040 ‚Ä¶fins‚Ä¶ 1048575)print flush
               }
	       {  %% Sup_PUA_B | Supplementary_Private_Use_Area_B [U+100000-U+10FFFF] ‚Ä¶del decimal‚Ä¶ 1048576 ‚Ä¶fins‚Ä¶ 1114111
                (\n\n )print flush xifrat 128 string cvs print flush
                ( <<< Unicode privat del bloc: Sup_PUA_B | Supplementary_Private_Use_Area_B [U+100000-U+10FFFF] ‚Ä¶del decimal‚Ä¶ 1048576 ‚Ä¶fins‚Ä¶ 1114111)print flush
               }ifelse
	      }ifelse
             }ifelse
            }ifelse
           }ifelse
	  }if
	 }
	 {  %% √©s un codi Unicode normatiu per√≤ podria tractar-se d'un codi que no podem consultar?
%%CAS04-A
          (\n\n )print flush xifrat 128 string cvs print flush ( <<< Unicode normatiu d'un glif que se'ns escapa o d'un codi de control sense glif)print flush
          dup 2 xifrat put /Aglif exch def  %% posem el codi Unicode a l'√≠ndex 2
	  (\n >>> podeu consultar a Unicode de quin glif i sistema d'escriptura o d'alfabet es tracta... https://util.unicode.org/UnicodeJsps/character.jsp?a=)print flush
          /sHexa 16 string def xifrat 16 sHexa cvrs print flush (\n\n)print flush
	 }ifelse
	}
        {  %% NO √©s dins l'AGL, per√≤ potser normatiu d'Unicode o estar en alguna de les dues √†rees d'√∫s privat sense glif assignat
%%CAS04-A
%10% si el /xifrat NO √©s DINS l'AGL, hem de mirar si el #codepoint √©s dins d'una √†rea PUA, si ho √©s, posarem un NULL a l'√≠ndex 2 d' /Aglif, i si no el seu #codepoint
%% si NO √©s normatiu d'Unicode n'informarem pel prompt de quina de les √†rees de les anomenades ¬´Unassigned, Private use, or Surrogates¬ª pertany:
         %% extret de‚Ä¶ blocsUnicode.ps
         %% un bloc que va del decimal‚Ä¶ 55296 ‚Ä¶al decimal‚Ä¶ 63743
            %% High_Surrogates [\uD800-\uDB7F] ‚Ä¶del decimal‚Ä¶ 55296 ‚Ä¶fins‚Ä¶ 56191
            %% High_Private_Use_Surrogates | High_PU_Surrogates [\uDB80-\uDBFF] ‚Ä¶del decimal‚Ä¶ 56192 ‚Ä¶fins‚Ä¶ 56319
            %% Low_Surrogates [\uDC00-\uDFFF] ‚Ä¶del decimal‚Ä¶ 56320 ‚Ä¶fins‚Ä¶ 57343
            %% PUA | Private_Use_Area | Private_Use [\uE000-\uF8FF] ‚Ä¶del decimal‚Ä¶ 57344 ‚Ä¶fins‚Ä¶ 63743
         %% un bloc que va del decimal‚Ä¶ 983040 ‚Ä¶al decimal‚Ä¶ 1114111
            %% Sup_PUA_A | Supplementary_Private_Use_Area_A [U+F0000-U+FFFFF] ‚Ä¶del decimal‚Ä¶ 983040 ‚Ä¶fins‚Ä¶ 1048575
            %% Sup_PUA_B | Supplementary_Private_Use_Area_B [U+100000-U+10FFFF] ‚Ä¶del decimal‚Ä¶ 1048576 ‚Ä¶fins‚Ä¶ 1114111

         xifrat 55296 ge xifrat 63743 le and xifrat 983040 ge xifrat 1114111 le and or
	 { %% filtra en quin dels 2 grans blocs ¬´Unassigned, Private use, or Surrogates¬ª podria pert√†nyer
          xifrat 55296 ge xifrat 63743 le and
	  {
           xifrat 56191 le
	   {  %% High_Surrogates [\uD800-\uDB7F] ‚Ä¶del decimal‚Ä¶ 55296 ‚Ä¶fins‚Ä¶ 56191
            (\n\n )print flush xifrat 128 string cvs print flush
            ( <<< Unicode privat del bloc: High_Surrogates [\\uD800-\\uDB7F] del decimal 55296 fins 56191)print flush
	   }
           {
            xifrat 56319 le
	    {  %% High_Private_Use_Surrogates | High_PU_Surrogates [\uDB80-\uDBFF] ‚Ä¶del decimal‚Ä¶ 56192 ‚Ä¶fins‚Ä¶ 56319
             (\n\n )print flush xifrat 128 string cvs print flush
             ( <<< Unicode privat del bloc: High_Private_Use_Surrogates | High_PU_Surrogates [\\uDB80-\\uDBFF] ‚Ä¶del decimal‚Ä¶ 56192 ‚Ä¶fins‚Ä¶ 56319)print flush
	    }
            {
             xifrat 57343 le
             {  %% Low_Surrogates [\uDC00-\uDFFF] ‚Ä¶del decimal‚Ä¶ 56320 ‚Ä¶fins‚Ä¶ 57343
              (\n\n )print flush xifrat 128 string cvs print flush
              ( <<< Unicode privat del bloc: Low_Surrogates [\\uDC00-\\uDFFF] ‚Ä¶del decimal‚Ä¶ 56320 ‚Ä¶fins‚Ä¶ 57343)print flush
	     }
             {
              xifrat 63743 le
	      {  %% PUA | Private_Use_Area | Private_Use [\uE000-\uF8FF] ‚Ä¶del decimal‚Ä¶ 57344 ‚Ä¶fins‚Ä¶ 63743
               (\n\n )print flush xifrat 128 string cvs print flush
               ( <<< Unicode privat del bloc: PUA | Private_Use_Area | Private_Use [\\uE000-\\uF8FF] ‚Ä¶del decimal‚Ä¶ 57344 ‚Ä¶fins‚Ä¶ 63743)print flush
	      }
              {  %% √©s entre 983040 i 1114111
               xifrat 1048575 le
               {  %% Sup_PUA_A | Supplementary_Private_Use_Area_A [U+F0000-U+FFFFF] ‚Ä¶del decimal‚Ä¶ 983040 ‚Ä¶fins‚Ä¶ 1048575
                (\n\n )print flush xifrat 128 string cvs print flush
                ( <<< Unicode privat del bloc: Sup_PUA_A | Supplementary_Private_Use_Area_A [U+F0000-U+FFFFF] ‚Ä¶del decimal‚Ä¶ 983040 ‚Ä¶fins‚Ä¶ 1048575)print flush
               }
	       {  %% Sup_PUA_B | Supplementary_Private_Use_Area_B [U+100000-U+10FFFF] ‚Ä¶del decimal‚Ä¶ 1048576 ‚Ä¶fins‚Ä¶ 1114111
                (\n\n )print flush xifrat 128 string cvs print flush
                ( <<< Unicode privat del bloc: Sup_PUA_B | Supplementary_Private_Use_Area_B [U+100000-U+10FFFF] ‚Ä¶del decimal‚Ä¶ 1048576 ‚Ä¶fins‚Ä¶ 1114111)print flush
               }ifelse
	      }ifelse
             }ifelse
            }ifelse
           }ifelse
	  }if
	 }
	 {  %% √©s un codi Unicode normatiu per√≤ al NO ser dins l'AGL pot tractar-se d'un codi de control (i.e. 129 sense glif) o d'altres que no podem consultar
%%CAS04-A
          (\n\n )print flush xifrat 128 string cvs print flush ( <<< Unicode normatiu d'un glif que se'ns escapa o d'un codi de control sense glif)print flush
          dup 2 xifrat put /Aglif exch def  %% posem el codi Unicode a l'√≠ndex 2
	  (\n >>> podeu consultar a Unicode de quin glif i sistema d'escriptura o d'alfabet es tracta... https://util.unicode.org/UnicodeJsps/character.jsp?a=)print flush
          /sHexa 16 string def xifrat 16 sHexa cvrs print flush (\n\n)print flush
	 }ifelse
        }ifelse  %% hi √©s o no dins l'AGL?
        %% desem l'array /Aglif dins l'array /araGlifs dels glifs a compondre
        Aglif araGlifs dup length dup /araVa exch def 1 add array dup 3 -1 roll 0 exch putinterval
        dup 3 -1 roll araVa exch put /araGlifs exch def
%(ARAsomAQUI)pstack quit
       }ifelse

%***% fi d'an√†lisi a replicar

%(nomeshiha1u)pstack quit
%        Nxifrat /.notdef eq
%        {
%         (\n\n !!! el codi decimal... )print flush xifrat 32 string cvs print flush ( ...no es troba dins el xifrat de l'AGL ...PLEGUEM!\n)print flush
%         ( >>> podeu consultar a Unicode de quin glif i sistema d'escriptura o d'alfabet es tracta... https://util.unicode.org/UnicodeJsps/character.jsp?a=)print flush
%         /sHexa 16 string def xifrat 16 sHexa cvrs print flush (\n\n)print flush quit
%        }if
%        Nxifrat araGlifs dup length dup /araVa exch def 1 add array dup 3 -1 roll 0 exch putinterval
%        dup 3 -1 roll araVa exch put /araGlifs exch def
%
       }
       {  %% si n'hi a 2 o m√©s hem d'iniciar l'embutit del xifrat
        pop  %% ens carreguem el decimal
        /desem false def  %% gatell per saber si ja tenim el c√†lcul decimal fet per codificar 1 sol glif
        bin nOctts 1 add dup 8 exch sub getinterval
(octetdecapsalera)pstack quit
       }ifelse
      }ifelse  %% √©s una excepci√≥ o √©s un octet de cap√ßalera
     }ifelse  %% √©s una excepci√≥ o √©s un octet de cap√ßalera
    }ifelse  %% √©s una excepci√≥ o √©s un octet de cap√ßalera
   }ifelse  %% √©s una excepci√≥ o √©s un octet de cap√ßalera
  }
  {  %% t√© 7 o menys bits significatius i el podr√≠em escriure directament per√≤, com que treballarem amb tota mena d' /encodingDtreball, activem m√©s filtres
%%CAS03
(te7omenysbitssignificatius)pstack quit
   dup 3 array dup 3 -1 roll 0 exch put dup dup  %% aqu√≠ hi desarem les 3 dades del glif, comen√ßant pel codi que ens ve de la cadena de text
   4 -1 roll encodingDtreball exch get 1 exch put  %% desem el nom que, per codi, li correspon a l'Encoding de treball (aqu√≠ no caldr√† comprovar-ho)
UUUUUUUI  %%EEEP abans hem de demanar si existeix! ens cal implementar-hi %***% ???
   dup 1 get AdobeGlyphList exch get 2 exch put  %% desem el seu codi Unicode que, per nom, li correspon dins l'AGL (aqu√≠ no caldr√† comprovar-ho)
   %% desem l'array de les 3 dades del glif dins l'array dels glifs a compondre
   araGlifs dup length dup /araVa exch def 1 add array dup 3 -1 roll 0 exch putinterval
   dup 3 -1 roll araVa exch put /araGlifs exch def
  }ifelse  %% t√© menys de 7 bits significatius, √©s una excepci√≥ o √©s un octet de cap√ßalera
 }
 {  %% no el desem perqu√® estem embutint el xifrat UTF-8 del glif?
(embutintoencaixantelglif?)pstack quit
 }ifelse
}forall  %% per tota la cadena de text

%% deixem a l'stack el resultat de la cadena de text analitzada
araGlifs
%% en un darrer an√†lisi que podr√≠em fer aqu√≠ (o activant un altre algorisme, veure espiaFontCharStrings_#.ps) i sempre que treballem en paral¬∑lel amb una tipografia
%% ens cal assegurar que el nom PS de cada glif existeixi dins el CharStrings de la font de treball (tots els que hi hagi dins /Aglif per√≤ indicant el seu √≠ndex)
%% fem una nova versi√≥ de‚Ä¶ espiaFontCharStrings_dic.ps per tal de desar al diccionari /CharStringsDtreball tots els noms PS dels glifs que contingui un tipus de lletra
%% potser tamb√© caldria tenir un sistema de substituci√≥ de glifs no trobats amb una gamma tipogr√†fica (p.e. la Noto Sans) per blocs Unicode (emojis, kanjis, etc)

(SOM a la CUA!) pstack

