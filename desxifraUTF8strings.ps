%!
%% https://www.rfc-editor.org/rfc/rfc3629
%% https://emnudge.dev/blog/utf-8/
%% https://util.unicode.org/UnicodeJsps/character.jsp
%% aquest algorisme ens ha de permetre treballar amb tot l'univers Unicode, aix√≤ √©s:
%% amb tota mena de sistemes d'escriptura i alfabets, per representar glifs d'una cadena de text llat√≠, cir√≠l¬∑lic, kanji, emoji, hangul, hiragana/katakana, arabic, etc
%% https://ca.wikipedia.org/wiki/Escriptura#/media/Fitxer:WritingSystemsoftheWorld.png

%%FILOSOFIA BREU:
%% desxifrem cadenes de text, glif a glif, en base a 2 refer√®ncies: l' /encodingDtreball d'acord amb la tipografia amb la que estiguem component
%% i a Unicode, d'acord amb els diccionaris de l'Adobe Glyph List (AGL). El sesultat pel desxifrat de cada glif √©s una array en format: 
%% [
%%  #codiE  codi decimal (enter) del glif dins l' /encodingDtreball, si no existeix hi deixaren un null
%%  [/nomPS ‚Ä¶ ] array amb 1 o m√©s noms PS del glif, on el primer de tots ser√† el que segur existeixi dins l' /encodingDtreball
%%  #codiU  codi decimal Unicode (enter) del glif dins l'AGL, si no existeix hi deixarem un null
%% ]
%% al final de l'algorisme hauriem de comprovar, glif a glif, que algun dels literals de l'array de noms PS existeix dins CharStrings del tipus a compondre

%% desxifrem les cadenes de text que, un cop a l'stack de l'int√®rpret GS, es destrien en octets combiables (UTF-8) de fins a 4 (32 bits) per a 1 sol glif
%% per tal de tornar-les a xifrar codificades a 1 sol codi decimal: √≠ndex a l' /encodingDtreball i/o codepoint hexa consultable a Unicode
%% i tamb√© el nom PS possible, aix√≤ √©s, el de dins l' /encodingDtreball, l'objecte /ToUnicode de PDF i a Unicode (l'AGL o d'altres que es puguin crear)
%% doncs segons els m√®todes de composici√≥ PostScript via show o via glyphshow necessitarem o un codi (codepoint) o un nom
%% cal tenir present que el GS quan codifica un car√†cter de m√©s de 7 bits significatius, dins una string en UTF-8, sempre ho fa amb notaci√≥ en base 8 \### octal
%% una A es codifica amb 1 sol octet (A)
%% un punt volat ¬∑ es codifica amb 2 octets (\302\267)
%% una el¬∑lipsi ‚Ä¶ es codifica amb 3 octets (\342\200\246)
%% hi ha emojis üòÄ i kanjis ©∏Ω que es codifiquen amb 4 octets (\360\237\230\200) (\360\251\270\275)

%% ara la refer√®ncia Unicode ser√† el diccionari AdobeGlyphList (/nomPS #codiUnicode) que es crida directament i on noms diferents poden compartir codi!
%% i la seva versi√≥ invertida ReverseAdobeGlyphList un diccionari (#codiUnicode [/nomsPSpossibles]) que es agrupa noms PS diferents dins un mateix codi decimal
/maxAGL 65510 def  %% aquest √©s el codi decimal m√©s gran codificat dins l'Adobe Glyph List (el m√©s petit √©s 1)
%% /MAX 0 def /MIN 100 def ReverseAdobeGlyphList {pop dup MAX gt{/MAX exch def}{dup MIN lt{/MIN exch def}{pop}ifelse}ifelse}forall

%% la casu√≠stica i el modus operandi que contemplarem ser√†:
%% si el xifrat √©s m√©s enll√† de l' /encodingDtreball a l'array 
%% si el xifrat √©s m√©s enll√† de maxAGL no l'escriurem, avisarem, i li assignarem un /.notdef
%% si el xifrat no es troba dins AGL no l'escriurem, avisarem, i li assignarem un /.notdef
%% si el xifrat es troba dins AGL per√≤ el codi √©s dins el rang de la PUA d'Unicode, avisarem, i escriurem el nom del glif
%% si el xifrat es troba dins AGL i √©s entre 0 i 255 (avisarem en mode debbug?) escriurem el codi
%% si el xifrat es troba dins AGL i √©s m√©s enll√† de 255 (avisarem en mode debbug?) escriurem el nom del glif
%% un cop localitzat(s) el(s) nom(s) del(s) glif(s) entre l' /encodingDtreball i l'AGL haur√≠em de comprovar si existeix dins CharString de la tipografia de treball
%% avisant si no hi √©s doncs, llavors, la maquin√†ria del tipus activaria un /.notdef

%%CASU√çSTICA A TENIR MOLT EN COMPTE
%% l'Adobe Glyph List s'adiu a Unicode, per√≤ un mateix codepoint pot tenir diversos noms PS de glif (p.e. 1488 [/alefhebrew /afii57664 /alef])
%% els codepoints decimals de l'AGL si els passem a hexa (p.e. 05D0 ‚Ä¶pel glif alef‚Ä¶ ◊ê) els podem consultar a‚Ä¶ https://util.unicode.org/UnicodeJsps/character.jsp?a=05d0
%% la WinAnsiEncoding NO s'adiu a Unicode en la codificaci√≥ de certs glifs: ie. l'el¬∑lipsi es codifica en decimal a 133 dins l'Encoding per√≤ a Unicode √©s a 8230
%% tampoc en el nom PS important‚Ä¶ /.notdef ‚Ä¶no √©s dins l'AGL i n'hi poden haver d'altres que estiguin dins l' /encodingDtreball i no a l'AGL

%% als Encondings predeterminats que hi ha dins l' /EncodingDirectory del GS hi ha tota una col¬∑lecci√≥ de noms de glif que no existeixen dins l'AGL
%% quan aix√≤ passi, per indicar-ho (a banda d'avisar pel prompt), posarem un null a la posici√≥ 1 de l'array de noms PS
%% si serv√≠s d'alguna cosa, podr√≠em desar-los via detectaglifsforadelAGL.ps
%% per la banda dels codis, cal veure quins codis de dins els Encodings predeterminats no s'adiuen o no es troben dins l'AGL
%% aquest comportament ens pot ser m√©s √∫til i ho podem consultar via fontEncodingGlifsNOunicode.ps
%% l'altra curiositat √©s saber quins glifs de l'AGL no s√≥n normatius d'Unicode doncs tenen el seu codepoint dins la PUA que va de‚Ä¶ <E000> 57344 ‚Ä¶fins‚Ä¶ <F8FF> 63743
%%CAL afegir-hi un altra bloc suplementari A i/o B de la PUA? https://util.unicode.org/UnicodeJsps/list-unicodeset.jsp?a=[%3ABlock%3DSupplementary_Private_Use_Area_B%3A]
%% ho podem veure a glifsPUAdinsAGL.ps

%% treballar la composici√≥ del text via codis decimals o via noms dels glifs, pot estar condicionada al xifrat de certs glifs m√©s enll√† de 255
%% fora de l'abast dels /Encoding tradicionals, de 256 elements, dels tipus de lletra que remena el GS
%%Experiment: qu√® passa si re-xifrem una tipografia amb un /Encoding d+d 256 elements?
%%ATENCI√ì: dins un context de produccci√≥, caldria treballar amb l' /Encoding de la tipografia en actiu‚Ä¶ currentfont /Encoding get ‚Ä¶doncs pot estar re-codificada!
systemdict /EncodingDirectory get
%/WinAnsiEncoding get
/StandardEncoding get  %% il¬∑lustra molt b√© el CAS02
%/ISOLatin1Encoding get
/encodingDtreball exch def
%% si treballem via nom del glif nom√©s ens caldra assegurar (havent pentinat abans els CharStrings del tipus, veure FuraFont) que el glif existeix dins la font activa

%% d'exemple de codi decimal que no hi √©s (sense superar maxAGL) tenim el cas del glif:
%% https://util.unicode.org/UnicodeJsps/character.jsp?a=30A0
%% <30A0> KATAKANA-HIRAGANA DOUBLE HYPHEN que equival a 16#30A0 = 12448 decimal i no es troba dins l'Adobe Glyph List
%% systemdict /AdobeGlyphList get {12448 eq{== stop}{pop}ifelse}forall
%% aquest glif („Ç†) un cop a l'stack es desglossa en (\343\202\240)

%% treballar dins un mateix text plans de codificaci√≥ diversos, en diferents sistemes d'escriptura, comportaria treballar simult√†niament amb diferents tipografies
%% i diferents /encodingDtreball que s'haurien de cridar segons el glif a compondre (s'hauria de saber com detectar la font de treball/Encoding)

%% encara no ho fem servir?
/d2a10 (2#00000000) def  %% primer tram de la m√†scara bin√†ria a codi decimal (radix number?)

/desem true def  %% gatell per saber si ja tenim el c√†lcul decimal fet (UTF-8 a 1 sol decimal) per codificar un sol glif

/araGlifs [] def  %% aqu√≠ √©s on desarem les arrays de cada glif amb triple descripci√≥



%%CASU√çSTICA de diferents comportament en el xifrat d'1 sol glif:

%%CAS##
%% testimoni de la Courier d'IBM que en certifica l'origen
%<F6BF>  %% codepoint 63167 a la PUA d'Unicode, ela geminada en caixa alta de nom /LL dins l'AGL
%<F6C0>  %% codepoint 63168 a la PUA d'Unicode, ela geminada en caixa baixa de nom /ll dins l'AGL

%%CAS##
%%EP! aquest √©s un cas que demostra que primer hem de consultar la WinAnsiEncoding i despr√©s l'AGL, doncs l'el¬∑lipsi existeix a la primer per√≤ NO a la segona
%(\342\200\246)  %% un cop a l'stack (‚Ä¶) el protocol UTF-8 la transforma en 3 octets que representen l'el¬∑lipsi on el seu nom PS dins l'Encoding √©s /ellipsis
%% s'ha d'embotir en un decimal que √©s 133 al WinAnsiEncoding de la font tipogr√†fica i per demostrar-ho:
%% systemdict /EncodingDirectory get /WinAnsiEncoding get 133 get == ens treu /ellipsis
%% systemdict /EncodingDirectory get /WinAnsiEncoding get /i 0 def {/ellipsis eq {i ==}if i 1 add /i exch def}forall ens treu 133
%(‚Ä¶)  %% per√≤ a Unicode el seu codepoint normatiu √©s a 8230

%%CAS##
%(\243)  %% 163 A3 s√≠mbol de la lliura esterlina /sterling

%%CAS##
%%FET
%(A)  %% 65 41 \101 lletra A maj√∫scula
%(AEIOUaeiou)

%%CAS##
%%FET
%% excepcions,, segons la normativa rfc3629, que mai no s√≥n octet de cap√ßalera
%<C0>  %% 192 \300 /Agrave
%<C1>  %% 193 \301 /Aacute
%<F5>  %% 245 \365 /otilde
%<FF>  %% 255 \377 /ydieresis
%<c0c1f5ff>

%%CAS##
%% aquest s'ha d'embotir perqu√® es destria en 3 UTF-8
%(„Ç†)  %% √©s un cas on per sota de maxAGL (codepoint 12448) no es troba dins l'AGL | Hiragana-Katakana Double Hyphen que a l'stack es desglossa en (\343\202\240)

%%CAS##
%% Unicode NON-BREAK SPACE (\240) cas d'un car√†cter amb 1 sol u de cap√ßalera al bit 8
%% que al WinAnsiEncoding t√© al decimal 160 el nom /space i que aqu√≠ correspon tamb√© a l'espai normal 32 decimal, per√≤ als noms de l'AGL no hi surt com a /space
%% en canvi el 32 decimal (<20> hexa) dins l'AGL t√© 2 noms dins l'array i /space no o cupa l'√≠ndex 0 dins aquest array de l'AGL
%% systemdict /EncodingDirectory get /WinAnsiEncoding get 0 1 255 { 2 copy get /space eq {==}{pop}ifelse }for
%<A0>

%%CAS##
%( )  %% <20> hi mancaria el filtrat a l'AGL doncs hi √©s i ara apareix fora d'un array

%%CAS##
%<00>  %% Error: /undefined in --get--

%%CAS##
%% 1 string dup 0 191 put  %% nom√©s hi ha un 1 al 8√® bit i existeix dins l'AGL

%%CAS01
%% si explorem la codificaci√≥ dels glifs que estan definits amb 1 sol octet per saber quins NO existeixen dins l'AGL i quins amb 8 bits sencers comencen per 10:
%% veurem que els que no existeixen dins l'AGL s√≥n el zero i del 128 al 159 i aquests darrers tenen 8 bits significatius i comencen tots per 10
% 0 1 255
% {  %% for
%  dup dup /8b 16 string def 2 8b cvrs dup length 8 eq
%  {  %% posant especial atenci√≥ als que tenen els 8 bits significatius
%   0 2 getinterval (10) eq
%   {  %% i d'aquestos els que comencen en 10
%    /a+ (*) def
%   }
%   {
%    /a+ () def
%   }ifelse
%  }
%  {
%   pop /a+ () def
%  }ifelse
%  ReverseAdobeGlyphList exch known
%  {
%   pop
%  }
%  {  %% anotem a pantalla quins NO existeixen
%   16 string cvs print flush a+ print flush (\n)print flush
%  }ifelse
% }for
1 string dup 0 159 put

%%CAS##
%% si explorem la codificaci√≥ de l'encoding m√©s habitual WinAnsiEncoding per veure quins glifs s√≥n /.notdef | veurem que s√≥n del 0 al 31
% systemdict /EncodingDirectory get /WinAnsiEncoding get 0 1 255{2 copy get /.notdef eq {==}{pop}ifelse}for



{  %% forall per tota la cadena de text
 dup /1octet exch def
 /8bits 8 string def  %% buffer de conversi√≥ d'1 octet a binari
 /8z (00000000) def  %% m√†scara de zeros a partir del segon octet

 desem
 {  %% hem de desar el glif? (el nom o el codi)
  /nOctts 0 def  %% nombre d'octets a interpretar
  dup 2 8bits cvrs dup /bin exch def length 8 eq
  {  %% podria tractar-se d'un octet de cap√ßalera?
   %% interroguem les excepcions que mai no s√≥n octet de cap√ßalera
   dup 192 eq  %% C0 \300 192 /Agrave
   {
    dup 3 array dup 3 -1 roll 0 exch put dup dup  %% aqu√≠ hi desarem les 3 dades del glif, comen√ßant pel codi que ens ve de la cadena de text
    4 -1 roll encodingDtreball exch get 1 exch put  %% desem el nom que, per codi, li correspon a l'Encoding de treball (aqu√≠ no caldr√† comprovar-ho)
    dup 1 get AdobeGlyphList exch get 2 exch put  %% desem el seu codi Unicode que, per nom, li correspon dins l'AGL (aqu√≠ no caldr√† comprovar-ho)
    %% desem l'array de les 3 dades del glif dins l'array dels glifs a compondre
    araGlifs dup length dup /araVa exch def 1 add array dup 3 -1 roll 0 exch putinterval
    dup 3 -1 roll araVa exch put /araGlifs exch def
%    nomocodi
%    {  %% via nom
%		(192 excepcio? Agrave)pstack quit
%    }
%    {  %% via codi
%     araLinia dup length dup /araVa exch def 1 add string dup 3 -1 roll 0 exch putinterval
%     dup 3 -1 roll araVa exch put /araLinia exch def
%%FET
%    }ifelse
   }
   {
    dup 193 eq  %% C1 \301 193 /Aacute
    {
     dup 3 array dup 3 -1 roll 0 exch put dup dup  %% aqu√≠ hi desarem les 3 dades del glif, comen√ßant pel codi que ens ve de la cadena de text
     4 -1 roll encodingDtreball exch get 1 exch put  %% desem el nom que, per codi, li correspon a l'Encoding de treball (aqu√≠ no caldr√† comprovar-ho)
     dup 1 get AdobeGlyphList exch get 2 exch put  %% desem el seu codi Unicode que, per nom, li correspon dins l'AGL (aqu√≠ no caldr√† comprovar-ho)
     %% desem l'array de les 3 dades del glif dins l'array dels glifs a compondre
     araGlifs dup length dup /araVa exch def 1 add array dup 3 -1 roll 0 exch putinterval
     dup 3 -1 roll araVa exch put /araGlifs exch def
%     nomocodi
%     {  %% via nom
%		(193 excepcio? Aacute)pstack quit
%     }
%     {  %% via codi
%      araLinia dup length dup /araVa exch def 1 add string dup 3 -1 roll 0 exch putinterval
%      dup 3 -1 roll araVa exch put /araLinia exch def
%%FET
%     }ifelse
    }
    {
     dup 245 eq  %% F5 \365 245 /otilde
     {
      dup 3 array dup 3 -1 roll 0 exch put dup dup  %% aqu√≠ hi desarem les 3 dades del glif, comen√ßant pel codi que ens ve de la cadena de text
      4 -1 roll encodingDtreball exch get 1 exch put  %% desem el nom que, per codi, li correspon a l'Encoding de treball (aqu√≠ no caldr√† comprovar-ho)
      dup 1 get AdobeGlyphList exch get 2 exch put  %% desem el seu codi Unicode que, per nom, li correspon dins l'AGL (aqu√≠ no caldr√† comprovar-ho)
      %% desem l'array de les 3 dades del glif dins l'array dels glifs a compondre
      araGlifs dup length dup /araVa exch def 1 add array dup 3 -1 roll 0 exch putinterval
      dup 3 -1 roll araVa exch put /araGlifs exch def
%      nomocodi
%      {  %% via nom
%		(245 excepcio? otilde)pstack quit
%      }
%      {  %% via codi
%       araLinia dup length dup /araVa exch def 1 add string dup 3 -1 roll 0 exch putinterval
%       dup 3 -1 roll araVa exch put /araLinia exch def
%%FET
%      }ifelse
     }
     {
      dup 255 eq  %% FF \377 255 /ydieresis
      {
       dup 3 array dup 3 -1 roll 0 exch put dup dup  %% aqu√≠ hi desarem les 3 dades del glif, comen√ßant pel codi que ens ve de la cadena de text
       4 -1 roll encodingDtreball exch get 1 exch put  %% desem el nom que, per codi, li correspon a l'Encoding de treball (aqu√≠ no caldr√† comprovar-ho)
       dup 1 get AdobeGlyphList exch get 2 exch put  %% desem el seu codi Unicode que, per nom, li correspon dins l'AGL (aqu√≠ no caldr√† comprovar-ho)
       %% desem l'array de les 3 dades del glif dins l'array dels glifs a compondre
       araGlifs dup length dup /araVa exch def 1 add array dup 3 -1 roll 0 exch putinterval
       dup 3 -1 roll araVa exch put /araGlifs exch def
%       nomocodi
%       {  %% via nom
%		(255 excepcio? ydieresis)pstack quit
%       }
%       {  %% via codi
%        araLinia dup length dup /araVa exch def 1 add string dup 3 -1 roll 0 exch putinterval
%        dup 3 -1 roll araVa exch put /araLinia exch def
%%FET
%       }ifelse
      }
      {  %% no el desarem perqu√® √©s un octet de cap√ßalera?
       /iOctts 0 def  %% comptador d'octets per codificar el glif
       bin
       {  %% forall per saber quants 1 hi ha seguits, fins al primer zero, que ens indicaran en quants octets UTF-8 s'ha descompost el glif
        49 eq
	{  %% √©s un 1
         iOctts 1 add /iOctts exch def
	}
        {  %% √©s un zero, desem i marxem
         iOctts /nOctts exch def  %% nombre d'octets a interpretar
	 exit
        }ifelse
       }forall

       iOctts 1 eq
       {  %% si nom√©s n'hi ha 1 ja l'hem d'escriure!
        %***% an√†lisi a replicar un cop tenim el codi definitu del glif:
        /xifrat exch def /Nxifrat /.notdef def
        %%1er via /xifrat consultem quin √©s el seu nom PS a l' /encodingDtreball
        encodingDtreball xifrat get /nompsE exch def
        %%2n consultem si /xifrat √©s dins l'AGL
        ReverseAdobeGlyphList xifrat known
        {  %%3er si /xifrat hi √©s, n'extraiem el(s) nom(s)
         ReverseAdobeGlyphList xifrat get /nompsAGL exch def
         %%4rt comparem el /nompsE amb el /nompsAGL reorganitzant l'array, si conv√©, per asseguranr-nos que el /nompsE √©s el primer element de l'array
         /nompsEhies false def  %% gatell per saber si √©s dins AGL o no
         nompsAGL 0 1 2 index length 1 sub
         {  %% for per saber si el literal /nompsE existeix dins l'array /nompsAGL
          %% doncs si no existeix, avisarem i haurem d'ampliar l'array /nompsAGL per ficar-li, sempre a la posici√≥ 0
          %% si existeix i no √©s a la posici√≥ 0 reorganitzarem l'array perqu√® hi sigui
          2 copy get nompsE eq
          {  %% hi √©s
           /nompsEhies true def
           exit
          }
          {
           pop
          }ifelse
         }for
         nompsEhies
         {  %% si hi √©s ens assegurem que √©s a la posici√≥ zero i si no reorganitzem l'array
          dup 0 eq
          {  %% √©s a la posici√≥ 0, o sigui al capdavant de l'array
           pop
          }
          {  %% no √©s a la posici√≥ 0 reorganizem l'array perqu√® hi estigui
           mark 3 1 roll  %% posem una marca per poder jugar qmab qualsevol nombre de noms de glifs
           /ai0 exch def  %% posici√≥ a l'stack que anir√† a l'√≠ndex zero
           aload pop counttomark ai0 roll
           counttomark array astore
           exch pop  %% ens carreguem la mark
          }ifelse
         }
         {  %% si no hi √©s, ampliem l'array i el posem a la posici√≥ 0
          dup length 1 add array dup dup 4 -1 roll 1 exch putinterval 0 nompsE put
         }ifelse
         %% aqu√≠ muntem l'array del glif amb les 3 dades
         3 array dup 3 -1 roll 1 exch put dup 0 xifrat put dup 2 xifrat put 
         %% desem l'array de les 3 dades del glif dins l'array dels glifs a compondre
         araGlifs dup length dup /araVa exch def 1 add array dup 3 -1 roll 0 exch putinterval
         dup 3 -1 roll araVa exch put /araGlifs exch def
        }
        {  %%6√® si /xifrat de l' /encodingDtreball NO hi √©s a l'AGL | exemple 159 <9f>
         %% primer buscarem si el seu nompsE √©s dins l'AGL
         AdobeGlyphList nompsE known
         {  %% SI hi √©s posarem el codi Unicode de l'aGL que li correspon
%%CAS01
(SI++-------------------)pstack quit
         } 
         {  %% si NO hi √©s posarem un null a l'√≠ndex 2 de l'array del glif
%%CAS02
(NO++-------------------)pstack quit
         }ifelse

         %% aqu√≠ muntem l'array del glif amb les 3 dades
         3 array dup 3 -1 roll 1 exch put dup 0 xifrat put dup 2 null put 
         %% desem l'array de les 3 dades del glif dins l'array dels glifs a compondre
         araGlifs dup length dup /araVa exch def 1 add array dup 3 -1 roll 0 exch putinterval
         dup 3 -1 roll araVa exch put %/araGlifs exch def
        }ifelse
        %***% fi d'an√†lisi a replicar

(nomeshiha1u)pstack quit

        %% tant si el trobem com si no, hem de descartar que el seu codi decimal sigui dins el rang PUA <E000> <f8ff> i/o els altres blocs sense normalitzar
        %% com el‚Ä¶ Supplementary_Private_Use_Area_A i Supplementary_Private_Use_Area_B ‚Ä¶en cas de ser un car√†cter no acceptat encara, per√≤ inclos a la font,
        %% o sigui dins el CharStrings, doncs tamb√© pot ser que no es trobi dins l' Encoding de la font (/encodingDtreball) o que no estigui en cap del dos llocs

        araPla {xifrat eq{/Nxifrat exch def exit}{pop}ifelse}forall

        Nxifrat /.notdef eq
        {
         (\n\n !!! el codi decimal... )print flush xifrat 32 string cvs print flush ( ...no es troba dins el xifrat de l'AGL ...PLEGUEM!\n)print flush
         ( >>> podeu consultar a Unicode de quin glif i sistema d'escriptura o d'alfabet es tracta... https://util.unicode.org/UnicodeJsps/character.jsp?a=)print flush
         /sHexa 16 string def xifrat 16 sHexa cvrs print flush (\n\n)print flush quit
        }if
        Nxifrat araGlifs dup length dup /araVa exch def 1 add array dup 3 -1 roll 0 exch putinterval
        dup 3 -1 roll araVa exch put /araGlifs exch def
       }
       {  %% si n'hi a 2 o m√©s hem d'iniciar l'embutit del xifrat
        pop  %% ens carreguem el decimal
        /desem false def  %% gatell per saber si ja tenim el c√†lcul decimal fet per codificar 1 sol glif
        bin nOctts 1 add dup 8 exch sub getinterval
(octetdecapsalera)pstack quit
       }ifelse
      }ifelse  %% √©s una excepci√≥ o √©s un octet de cap√ßalera
     }ifelse  %% √©s una excepci√≥ o √©s un octet de cap√ßalera
    }ifelse  %% √©s una excepci√≥ o √©s un octet de cap√ßalera
   }ifelse  %% √©s una excepci√≥ o √©s un octet de cap√ßalera
  }
  {  %% t√© 7 o menys bits significatius i l'escrivim directament
   dup 3 array dup 3 -1 roll 0 exch put dup dup  %% aqu√≠ hi desarem les 3 dades del glif, comen√ßant pel codi que ens ve de la cadena de text
   4 -1 roll encodingDtreball exch get 1 exch put  %% desem el nom que, per codi, li correspon a l'Encoding de treball (aqu√≠ no caldr√† comprovar-ho)
UUUUUUUI  %%EEEP abans hem de demanar si existeix! ens cal implementar-hi %***% ???
   dup 1 get AdobeGlyphList exch get 2 exch put  %% desem el seu codi Unicode que, per nom, li correspon dins l'AGL (aqu√≠ no caldr√† comprovar-ho)
   %% desem l'array de les 3 dades del glif dins l'array dels glifs a compondre
   araGlifs dup length dup /araVa exch def 1 add array dup 3 -1 roll 0 exch putinterval
   dup 3 -1 roll araVa exch put /araGlifs exch def
%   nomocodi
%   {  %% via nom
%   }
%   {  %% via codi
%    araLinia dup length dup /araVa exch def 1 add string dup 3 -1 roll 0 exch putinterval
%    dup 3 -1 roll araVa exch put /araLinia exch def
%%FET
%   }ifelse
%(te7omenysbitssignificatius)pstack quit
  }ifelse  %% t√© menys de 7 bits significatius, √©s una excepci√≥ o √©s un octet de cap√ßalera
 }
 {  %% no el desem perqu√® estem embutint el xifrat UTF-8 del glif?
(encaixantelglif)pstack quit
 }ifelse
}forall  %% per tota la cadena de text

%% deixem a l'stack el resultat de la cadena de text analitzada i que ara mostrem en forma d'array
araGlifs
%% en un darrer an√†lisi que podr√≠em fer aqu√≠ (o activant un altre algorisme, veure espiaFontCharStrings_#.ps)
%% ens cal assegurar de cada glif que el seu nom PS (el primer o no de l'array) existeixi dins CharStrings de la font de treball
%% fem una nova versi√≥ de‚Ä¶ espiaFontCharStrings_dic.ps per tal de desar al diccionari /CharStringsDtreball tots els noms PS dels glifs que contingui un tipus de lletra

pstack

